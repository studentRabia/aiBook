---
id: 3.1-isaac-sim-basics
title: "3.1 NVIDIA Isaac Sim Fundamentals"
sidebar_position: 2
---

# 3.1 NVIDIA Isaac Sim Fundamentals

## Overview

NVIDIA Isaac Sim is a scalable robotics simulation platform built on Omniverse. It provides GPU-accelerated physics, photorealistic rendering with ray tracing, and seamless ROS 2 integration. This chapter covers setting up Isaac Sim for humanoid robot simulation.

## Learning Objectives

By the end of this chapter, you will be able to:

- Install and configure NVIDIA Isaac Sim
- Understand Omniverse architecture and USD format
- Import robots and create simulation scenes
- Connect Isaac Sim to ROS 2
- Run physics simulations with GPU acceleration

## Prerequisites

- NVIDIA RTX GPU (RTX 2070 or better recommended)
- Ubuntu 22.04 LTS
- NVIDIA Driver 525+ and CUDA 12.0+
- Completed Module 2 (Digital Twin concepts)

## 3.1.1 Why Isaac Sim?

Isaac Sim offers significant advantages for robotics:

| Feature | Benefit |
|---------|---------|
| PhysX 5 | GPU-accelerated physics for thousands of robots |
| RTX Ray Tracing | Photorealistic rendering for vision training |
| USD Format | Industry-standard scene description |
| Domain Randomization | Built-in tools for sim-to-real transfer |
| ROS 2 Bridge | Native integration with ROS 2 |
| Synthetic Data | Automatic annotation and labeling |

## 3.1.2 Installation

### System Requirements

```bash
# Check GPU
nvidia-smi

# Minimum: RTX 2070, 8GB VRAM
# Recommended: RTX 3080+, 12GB+ VRAM
# RAM: 32GB minimum, 64GB recommended
```

### Install Isaac Sim via Omniverse Launcher

1. Download Omniverse Launcher from NVIDIA
2. Install Isaac Sim from the Exchange tab
3. Launch Isaac Sim

```bash
# Alternative: Container deployment
docker pull nvcr.io/nvidia/isaac-sim:2023.1.1

docker run --gpus all -e "ACCEPT_EULA=Y" \
  --rm --network=host \
  -v ~/docker/isaac-sim/cache/kit:/isaac-sim/kit/cache:rw \
  -v ~/docker/isaac-sim/cache/ov:/root/.cache/ov:rw \
  -v ~/docker/isaac-sim/cache/pip:/root/.cache/pip:rw \
  -v ~/docker/isaac-sim/cache/glcache:/root/.cache/nvidia/GLCache:rw \
  -v ~/docker/isaac-sim/cache/computecache:/root/.nv/ComputeCache:rw \
  -v ~/docker/isaac-sim/logs:/root/.nvidia-omniverse/logs:rw \
  -v ~/docker/isaac-sim/data:/root/.local/share/ov/data:rw \
  nvcr.io/nvidia/isaac-sim:2023.1.1
```

## 3.1.3 Omniverse and USD

### Universal Scene Description (USD)

USD is Pixar's scene description format, now the standard for robotics simulation:

```python
# Basic USD structure
from pxr import Usd, UsdGeom, UsdPhysics

# Create a new stage
stage = Usd.Stage.CreateNew("humanoid_scene.usda")

# Set up axis and units
UsdGeom.SetStageUpAxis(stage, UsdGeom.Tokens.z)
UsdGeom.SetStageMetersPerUnit(stage, 1.0)

# Create a ground plane
ground = UsdGeom.Mesh.Define(stage, "/World/Ground")
ground.CreatePointsAttr([(-10, -10, 0), (10, -10, 0), (10, 10, 0), (-10, 10, 0)])
ground.CreateFaceVertexCountsAttr([4])
ground.CreateFaceVertexIndicesAttr([0, 1, 2, 3])

# Add physics
physics_scene = UsdPhysics.Scene.Define(stage, "/World/PhysicsScene")
physics_scene.CreateGravityDirectionAttr().Set((0, 0, -1))
physics_scene.CreateGravityMagnitudeAttr().Set(9.81)

stage.Save()
```

### Scene Hierarchy

```
/World
├── /PhysicsScene
├── /Environment
│   ├── /Ground
│   ├── /Lights
│   └── /Props
└── /Robots
    └── /Humanoid
        ├── /torso
        ├── /left_arm
        ├── /right_arm
        ├── /left_leg
        └── /right_leg
```

## 3.1.4 Importing Robots

### URDF to USD Conversion

```python
# urdf_import.py
import omni.kit.commands
from omni.isaac.urdf import _urdf

# Configure URDF import
urdf_config = _urdf.ImportConfig()
urdf_config.merge_fixed_joints = False
urdf_config.fix_base = False
urdf_config.import_inertia_tensor = True
urdf_config.distance_scale = 1.0
urdf_config.density = 1000.0
urdf_config.default_drive_type = _urdf.UrdfJointTargetType.JOINT_DRIVE_POSITION
urdf_config.default_drive_strength = 1000.0
urdf_config.default_position_drive_damping = 100.0

# Import URDF
result, prim_path = omni.kit.commands.execute(
    "URDFParseAndImportFile",
    urdf_path="/path/to/humanoid.urdf",
    import_config=urdf_config
)

print(f"Robot imported at: {prim_path}")
```

### Direct USD Robot Creation

```python
# create_humanoid.py
from omni.isaac.core.articulations import ArticulationView
from omni.isaac.core.utils.stage import add_reference_to_stage

# Add robot from USD
robot_prim_path = "/World/Humanoid"
add_reference_to_stage(
    usd_path="/path/to/humanoid.usd",
    prim_path=robot_prim_path
)

# Create articulation view for control
robots = ArticulationView(
    prim_paths_expr="/World/Humanoid",
    name="humanoid_view"
)
```

## 3.1.5 Physics Configuration

### PhysX Settings for Humanoids

```python
# physics_config.py
from omni.isaac.core import World
from omni.physx import get_physx_scene_query_interface

# Create simulation world
world = World(
    stage_units_in_meters=1.0,
    physics_dt=1/500.0,  # 500 Hz for stable humanoid sim
    rendering_dt=1/60.0   # 60 FPS rendering
)

# Configure PhysX
physx_interface = get_physx_scene_query_interface()

# Set solver iterations (higher = more stable but slower)
from pxr import PhysxSchema
physx_scene = PhysxSchema.PhysxSceneAPI.Apply(
    world.stage.GetPrimAtPath("/World/PhysicsScene")
)
physx_scene.CreateSolverTypeAttr().Set("TGS")  # Temporal Gauss-Seidel
physx_scene.CreateEnableCCDAttr().Set(True)    # Continuous collision detection
physx_scene.CreateEnableGPUDynamicsAttr().Set(True)
physx_scene.CreateBroadphaseTypeAttr().Set("GPU")
```

### Contact Configuration

```python
# contact_config.py
from pxr import UsdPhysics, PhysxSchema

def configure_foot_contact(foot_prim_path):
    """Configure foot collision for stable ground contact"""
    stage = omni.usd.get_context().get_stage()
    foot_prim = stage.GetPrimAtPath(foot_prim_path)

    # Add collision API
    collision_api = UsdPhysics.CollisionAPI.Apply(foot_prim)

    # Configure PhysX material
    material_api = PhysxSchema.PhysxMaterialAPI.Apply(foot_prim)
    material_api.CreateStaticFrictionAttr().Set(1.0)
    material_api.CreateDynamicFrictionAttr().Set(0.8)
    material_api.CreateRestitutionAttr().Set(0.0)

    # Configure contact reporting
    contact_api = PhysxSchema.PhysxContactReportAPI.Apply(foot_prim)
    contact_api.CreateThresholdAttr().Set(0.0)
```

## 3.1.6 ROS 2 Integration

### Enable ROS 2 Bridge

```python
# ros2_bridge.py
import omni.graph.core as og
from omni.isaac.core_nodes.scripts.utils import set_target_prims

# Create ROS 2 clock publisher
og.Controller.edit(
    {"graph_path": "/ActionGraph", "evaluator_name": "execution"},
    {
        og.Controller.Keys.CREATE_NODES: [
            ("OnPlaybackTick", "omni.graph.action.OnPlaybackTick"),
            ("ROS2Context", "omni.isaac.ros2_bridge.ROS2Context"),
            ("ClockPublisher", "omni.isaac.ros2_bridge.ROS2PublishClock"),
        ],
        og.Controller.Keys.CONNECT: [
            ("OnPlaybackTick.outputs:tick", "ClockPublisher.inputs:execIn"),
            ("ROS2Context.outputs:context", "ClockPublisher.inputs:context"),
        ],
    }
)
```

### Joint State Publisher

```python
# joint_state_publisher.py
def create_joint_state_graph(robot_prim_path):
    """Create OmniGraph for publishing joint states to ROS 2"""

    og.Controller.edit(
        {"graph_path": "/JointStateGraph", "evaluator_name": "execution"},
        {
            og.Controller.Keys.CREATE_NODES: [
                ("OnPlaybackTick", "omni.graph.action.OnPlaybackTick"),
                ("ROS2Context", "omni.isaac.ros2_bridge.ROS2Context"),
                ("ReadJointState", "omni.isaac.core_nodes.IsaacReadSimulationTime"),
                ("ArticulationState", "omni.isaac.core_nodes.IsaacArticulationState"),
                ("JointStatePublisher", "omni.isaac.ros2_bridge.ROS2PublishJointState"),
            ],
            og.Controller.Keys.SET_VALUES: [
                ("ArticulationState.inputs:targetPrim", robot_prim_path),
                ("JointStatePublisher.inputs:topicName", "/joint_states"),
            ],
            og.Controller.Keys.CONNECT: [
                ("OnPlaybackTick.outputs:tick", "ArticulationState.inputs:execIn"),
                ("ArticulationState.outputs:jointNames", "JointStatePublisher.inputs:jointNames"),
                ("ArticulationState.outputs:jointPositions", "JointStatePublisher.inputs:jointPositions"),
                ("ArticulationState.outputs:jointVelocities", "JointStatePublisher.inputs:jointVelocities"),
            ],
        }
    )
```

## 3.1.7 Running Simulations

### Standalone Python Script

```python
# standalone_sim.py
from omni.isaac.kit import SimulationApp

# Launch Isaac Sim
config = {
    "headless": False,
    "width": 1280,
    "height": 720
}
simulation_app = SimulationApp(config)

# Now import Isaac modules
from omni.isaac.core import World
from omni.isaac.core.robots import Robot

# Create world and add robot
world = World(physics_dt=1/500.0)
world.scene.add_default_ground_plane()

# Add humanoid robot
robot = Robot(
    prim_path="/World/Humanoid",
    name="humanoid",
    usd_path="/path/to/humanoid.usd"
)
world.scene.add(robot)

# Reset and run simulation
world.reset()

while simulation_app.is_running():
    world.step(render=True)

    # Get robot state
    joint_positions = robot.get_joint_positions()
    joint_velocities = robot.get_joint_velocities()

    # Apply control
    target_positions = compute_target_positions()
    robot.set_joint_positions(target_positions)

simulation_app.close()
```

## Hands-On Exercise

1. Install Isaac Sim via Omniverse Launcher
2. Import a humanoid URDF and convert to USD
3. Configure physics for stable humanoid simulation
4. Set up ROS 2 bridge for joint state publishing
5. Run a basic simulation stepping loop

## Summary

In this chapter, you learned:

- Installing and configuring NVIDIA Isaac Sim
- Understanding USD format and scene structure
- Importing robots from URDF
- Configuring PhysX for humanoid simulation
- Integrating with ROS 2 via OmniGraph

## Next Steps

Continue to [3.2 Synthetic Data Generation](3.2-synthetic-data) to learn how to generate training data at scale using Isaac Sim's Replicator.
